name: Terraform - Detect Changes and Create Tags

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  check-merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      merged: ${{ steps.check.outputs.merged }}
    steps:
      - id: check
        run: echo "merged=true" >> $GITHUB_OUTPUT

  load-config:
    needs: check-merged
    runs-on: ubuntu-latest
    outputs:
      stacks: ${{ steps.config.outputs.stacks }}
      stack_paths: ${{ steps.config.outputs.stack_paths }}
      environments: ${{ steps.config.outputs.environments }}
      base_path: ${{ steps.config.outputs.base_path }}
    steps:
      - uses: actions/checkout@v3

      - id: config
        name: Load repository configuration
        run: |
          if [ -f ".github/config.json" ]; then
            STACKS=$(jq -r '.stacks | keys | join(",")' .github/config.json)
            STACK_PATHS=$(jq -c '.stacks' .github/config.json)
            ENVIRONMENTS=$(jq -r '.environments | join(",")' .github/config.json)
            BASE_PATH=$(jq -r '.basePath // "stacks"' .github/config.json)

            echo "stacks=$STACKS" >> $GITHUB_OUTPUT
            echo "stack_paths=$STACK_PATHS" >> $GITHUB_OUTPUT
            echo "environments=$ENVIRONMENTS" >> $GITHUB_OUTPUT
            echo "base_path=$BASE_PATH" >> $GITHUB_OUTPUT
          else
            echo "Error: .github/config.json not found"
            exit 1
          fi

  detect-changes:
    needs: [check-merged, load-config]
    runs-on: ubuntu-latest
    outputs:
      changed_stacks: ${{ steps.detect.outputs.changed_stacks }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v3

      - name: Create dynamic path filter
        id: create_filter
        run: |
          STACK_PATHS='${{ needs.load-config.outputs.stack_paths }}'
          STACKS=($(echo '${{ needs.load-config.outputs.stacks }}' | tr ',' ' '))

          echo "Creating filter configuration..."
          FILTER="{\"filters\": {"

          for STACK in "${STACKS[@]}"; do
            PATH=$(echo $STACK_PATHS | jq -r ".[\"$STACK\"].path")
            FILTER="$FILTER\"$STACK\": [\"$PATH\"],"
          done

          # Remove trailing comma and close JSON
          FILTER="${FILTER%,}}"

          echo "$FILTER" > filter.json
          cat filter.json

      - name: Filter for Terraform stack changes
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters-file: filter.json

      - id: detect
        name: Detect changed stacks
        run: |
          CHANGES=$(echo '${{ toJSON(steps.filter.outputs.changes) }}')

          if [ "$CHANGES" != "[]" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "changed_stacks=$CHANGES" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "changed_stacks=[]" >> $GITHUB_OUTPUT
          fi

  parse-pr-environments:
    needs: [check-merged, detect-changes, load-config]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      selected_environments: ${{ steps.parse.outputs.selected_environments }}
      auto_promote: ${{ steps.parse.outputs.auto_promote }}
      required_approvals: ${{ steps.parse.outputs.required_approvals }}
    steps:
      - id: parse
        name: Parse PR body for environment selection
        run: |
          PR_BODY="${{ github.event.pull_request.body }}"
          ENVIRONMENTS=($(echo '${{ needs.load-config.outputs.environments }}' | tr ',' ' '))

          # Initialize empty array
          SELECTED_ENVS="["

          # Check each environment
          for ENV in "${ENVIRONMENTS[@]}"; do
            # Use shell pattern matching instead of grep
            if [[ "$PR_BODY" == *"- [x] $ENV"* ]]; then
              SELECTED_ENVS="$SELECTED_ENVS\"$ENV\","
            fi
          done

          # Remove trailing comma and close array
          SELECTED_ENVS="${SELECTED_ENVS%,}]"

          # Simplified auto-promote detection
          if [[ "$PR_BODY" == *"Auto-promote: yes"* ]]; then
            AUTO_PROMOTE="true"
          else
            AUTO_PROMOTE="false"
          fi

          # Extract required approvals with pattern matching
          APPROVALS=$(echo "$PR_BODY" | grep -E "Required approvals: *[0-9]+" | grep -E -o "[0-9]+" || echo "1")

          echo "selected_environments=$SELECTED_ENVS" >> $GITHUB_OUTPUT
          echo "auto_promote=$AUTO_PROMOTE" >> $GITHUB_OUTPUT
          echo "required_approvals=$APPROVALS" >> $GITHUB_OUTPUT

  create-tags-and-issues:
    needs: [detect-changes, parse-pr-environments, load-config]
    if: ${{ needs.detect-changes.outputs.has_changes == 'true' && fromJSON(needs.parse-pr-environments.outputs.selected_environments)[0] != null }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get current date
        id: date
        run: |
          echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

      - name: Create tags and tracking issues
        id: create_tags
        uses: actions/github-script@v6
        with:
          script: |
            const date = '${{ steps.date.outputs.date }}';
            const changedStacks = ${{ needs.detect-changes.outputs.changed_stacks }};
            const selectedEnvs = ${{ needs.parse-pr-environments.outputs.selected_environments }};
            const autoPromote = ${{ needs.parse-pr-environments.outputs.auto_promote }};
            const requiredApprovals = ${{ needs.parse-pr-environments.outputs.required_approvals }};
            const basePath = '${{ needs.load-config.outputs.base_path }}';

            // Process each changed stack
            for (const stack of changedStacks) {
              console.log(`Processing stack: ${stack}`);

              // Create tag
              const tagName = `${date}-${stack}`;

              try {
                // Create and push the tag
                await exec.exec('git', ['config', 'user.name', 'GitHub Actions']);
                await exec.exec('git', ['config', 'user.email', 'actions@github.com']);
                await exec.exec('git', ['tag', tagName]);
                await exec.exec('git', ['push', 'origin', tagName]);

                console.log(`Created tag: ${tagName}`);

                // Create tracking issue
                const statusTable = selectedEnvs.map(env =>
                  `| ${env.toUpperCase()} | Pending | - | - | - |`
                ).join('\n');

                const { data: issue } = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `Deployment Tracking: ${tagName}`,
                  body: `## Deployment Tracking for ${stack}

                  **Tag:** \`${tagName}\`
                  **Stack:** ${stack}
                  **Created By:** ${context.actor}
                  **Original PR:** #${{ github.event.pull_request.number }}

                  ## Deployment Configuration
                  - Auto-promote: ${autoPromote ? 'Yes' : 'No'}
                  - Required approvals: ${requiredApprovals}
                  - Selected environments: ${selectedEnvs.join(', ')}

                  ## Deployment Status

                  | Environment | Status | Deployed At | PR | Approver |
                  |-------------|--------|-------------|-------|----------|
                  ${statusTable}

                  ## Activity Log

                  - ${new Date().toISOString()}: Deployment issue created for stack ${stack}
                  `,
                  labels: ['deployment', 'terraform', stack]
                });

                console.log(`Created tracking issue #${issue.number}`);

                // Create PR for first environment in the selection
                const firstEnv = selectedEnvs[0];
                await createEnvironmentPR(stack, tagName, firstEnv, issue.number, autoPromote, requiredApprovals, selectedEnvs, basePath);
              } catch (error) {
                console.error(`Error processing stack ${stack}: ${error}`);
              }
            }

            // Helper function to create environment PR
            async function createEnvironmentPR(stack, tag, env, issueNumber, autoPromote, requiredApprovals, selectedEnvs, basePath) {
              const branchName = `deploy/${tag}/${env}`;

              // Create branch
              await exec.exec('git', ['checkout', '-b', branchName]);

              // Create deployment manifest file
              const fs = require('fs');
              const deploymentConfig = {
                tag: tag,
                stack: stack,
                environment: env,
                issue: issueNumber,
                auto_promote: autoPromote,
                required_approvals: requiredApprovals,
                selected_environments: selectedEnvs,
                base_path: basePath
              };

              fs.writeFileSync('deployment.json', JSON.stringify(deploymentConfig, null, 2));

              // Commit and push
              await exec.exec('git', ['add', 'deployment.json']);
              await exec.exec('git', ['commit', '-m', `Deployment plan for ${stack} to ${env}`]);
              await exec.exec('git', ['push', '--set-upstream', 'origin', branchName]);

              // Create progress indicator for PR description
              const progressList = selectedEnvs.map(selectedEnv => {
                if (selectedEnv === env) {
                  return `- [x] ${selectedEnv.toUpperCase()} (this PR)`;
                } else {
                  return `- [ ] ${selectedEnv.toUpperCase()} (pending)`;
                }
              }).join('\n');

              // Create PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `🚀 Deploy ${stack} to ${env.toUpperCase()}`,
                body: `This PR will deploy the \`${stack}\` stack to the ${env.toUpperCase()} environment.

                **Deployment Tag:** \`${tag}\`
                **Tracking Issue:** #${issueNumber}
                **Original PR:** #${{ github.event.pull_request.number }}
                **Auto-promote:** ${autoPromote ? 'Yes' : 'No'}
                **Required Approvals:** ${requiredApprovals}

                ## Deployment Progress
                ${progressList}

                ## Deployment Process
                1. Review the Terraform plan added as a comment to this PR
                2. Approve and merge this PR to deploy to ${env.toUpperCase()}
                ${autoPromote ? '3. The next environment PR will be created automatically upon successful deployment' : '3. After deployment, manually create the next environment PR if desired'}

                This is part of a deployment tracked in issue #${issueNumber}.
                `,
                head: branchName,
                base: 'main'
              });

              console.log(`Created PR #${pr.number} for ${stack} to ${env}`);

              // Update tracking issue with PR link
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `## ${env.toUpperCase()} Deployment PR Created

                PR #${pr.number} has been created to deploy stack \`${stack}\` to the ${env.toUpperCase()} environment.
                `
              });
            }